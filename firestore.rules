rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ── User data ─────────────────────────────────────────
    // Each user owns their own document (personal babies + events).
    match /users/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    // ── Invite codes ──────────────────────────────────────
    // Any signed-in user can read (needed to join via code).
    // Any signed-in user can create (owner creates when sharing).
    // Only the owner of the linked sharedBaby can delete.
    match /inviteCodes/{code} {
      allow read:   if request.auth != null;
      allow create: if request.auth != null;
      allow delete: if request.auth != null &&
        get(/databases/$(database)/documents/sharedBabies/$(resource.data.shareId)).data.ownerUid
          == request.auth.uid;
    }

    // ── Shared babies ─────────────────────────────────────
    match /sharedBabies/{shareId} {

      // Any signed-in user can read the baby doc.
      // Needed so a joiner can fetch baby info before they're added to memberUids.
      // (The baby doc only holds profile data — name, emoji, dob — not tracking events.)
      allow read: if request.auth != null;

      // Any signed-in user can create (they set ownerUid to themselves).
      allow create: if request.auth != null &&
        request.auth.uid == request.resource.data.ownerUid;

      // Update is allowed if:
      //   a) already a member (owner editing baby info, or leaving via arrayRemove), OR
      //   b) a new user adding themselves via arrayJoin — they must be in the new
      //      memberUids list, must not remove anyone else, and all other fields
      //      must be unchanged (prevents arbitrary writes by outsiders).
      allow update: if request.auth != null && (
        request.auth.uid in resource.data.memberUids
        ||
        (
          request.auth.uid in request.resource.data.memberUids &&
          request.resource.data.memberUids.hasAll(resource.data.memberUids) &&
          request.resource.data.ownerUid    == resource.data.ownerUid &&
          request.resource.data.inviteCode  == resource.data.inviteCode
        )
      );

      // Only the owner can delete the shared baby doc.
      allow delete: if request.auth != null &&
        request.auth.uid == resource.data.ownerUid;

      // ── Events subcollection ──────────────────────────
      // Only members of the parent baby can read or write events.
      match /events/{evId} {
        allow read, write: if request.auth != null &&
          request.auth.uid in
            get(/databases/$(database)/documents/sharedBabies/$(shareId)).data.memberUids;
      }
    }

  }
}
